#include "matrix.h"
#include <string.h>

/* ================= CONFIG ================= */
#define TOTAL_BYTES 11

/* ================= FRAMEBUFFER ================= */
static uint8_t display_buffer[NUM_ROWS][TOTAL_BYTES];

static uint8_t current_row = 0;

/* ================= ROW PINS ================= */
const uint16_t ROW_PINS[NUM_ROWS] =
{
    A1_Pin,
    A2_Pin,
    A3_Pin,
    A4_Pin,
    A5_Pin,
    A6_Pin,
    A7_Pin
};

/* ================= FONT ================= */
static const uint8_t font5x7[128][5] =
{
[' ']={0,0,0,0,0},

[':'] = {0x00, 0x36, 0x36, 0x00, 0x00},  // :
[';'] = {0x00, 0x56, 0x36, 0x00, 0x00},  // ;
[','] = {0x00, 0x40, 0xE0, 0x00, 0x00},  // ,
['.'] = {0x00, 0x60, 0x60, 0x00, 0x00},  // .
['"'] = {0x00, 0x07, 0x07, 0x00, 0x00},  // "
['\''] = {0x00, 0x07, 0x00, 0x00, 0x00}, // ' (single quote)
['-'] = {0x08, 0x08, 0x08, 0x08, 0x08},  // - (horizontal line, centered)
['+'] = {0x08, 0x08, 0x3E, 0x08, 0x08},  // +
['*'] = {0x14, 0x08, 0x3E, 0x08, 0x14},  // *
['('] = {0x00, 0x1C, 0x22, 0x41, 0x00},  // (
[')'] = {0x00, 0x41, 0x22, 0x1C, 0x00},  // )
['$'] = {0x24, 0x2A, 0x7F, 0x2A, 0x12},  // $
['#'] = {0x14, 0x7F, 0x14, 0x7F, 0x14},  // #
['@'] = {0x3E, 0x45, 0x4D, 0x55, 0x3E},  // @ (common compact version)
['!'] = {0x00, 0x00, 0x4F, 0x00, 0x00},  // !
['?'] = {0x02, 0x01, 0x51, 0x09, 0x06},  // ?
['^'] = {0x04, 0x02, 0x01, 0x02, 0x04},  // ^
['&'] = {0x32, 0x49, 0x49, 0x26, 0x50},  // & (ampersand)
['<'] = {0x08, 0x14, 0x22, 0x41, 0x00},  // <
['>'] = {0x00, 0x41, 0x22, 0x14, 0x08},  // >

['0']={0x3E,0x51,0x49,0x45,0x3E},
['1']={0x00,0x42,0x7F,0x40,0x00},
['2']={0x62,0x51,0x49,0x49,0x46},
['3']={0x22,0x49,0x49,0x49,0x36},
['4']={0x18,0x14,0x12,0x7F,0x10},
['5']={0x2F,0x49,0x49,0x49,0x31},
['6']={0x3E,0x49,0x49,0x49,0x32},
['7']={0x01,0x71,0x09,0x05,0x03},
['8']={0x36,0x49,0x49,0x49,0x36},
['9']={0x26,0x49,0x49,0x49,0x3E},

['A']={0x7E,0x11,0x11,0x11,0x7E},
['B']={0x7F,0x49,0x49,0x49,0x36},
['C']={0x3E,0x41,0x41,0x41,0x22},
['D']={0x7F,0x41,0x41,0x22,0x1C},
['E']={0x7F,0x49,0x49,0x49,0x41},
['F']={0x7F,0x09,0x09,0x09,0x01},
['G']={0x3E,0x41,0x49,0x49,0x7A},
['H']={0x7F,0x08,0x08,0x08,0x7F},
['I']={0x00,0x41,0x7F,0x41,0x00},
['J']={0x20,0x40,0x41,0x3F,0x01},
['K']={0x7F,0x08,0x14,0x22,0x41},
['L']={0x7F,0x40,0x40,0x40,0x40},
['M']={0x7F,0x02,0x0C,0x02,0x7F},
['N']={0x7F,0x04,0x08,0x10,0x7F},
['O']={0x3E,0x41,0x41,0x41,0x3E},
['P']={0x7F,0x09,0x09,0x09,0x06},
['Q']={0x3E,0x41,0x51,0x21,0x5E},
['R']={0x7F,0x09,0x19,0x29,0x46},
['S']={0x46,0x49,0x49,0x49,0x31},
['T']={0x01,0x01,0x7F,0x01,0x01},
['U']={0x3F,0x40,0x40,0x40,0x3F},
['V']={0x1F,0x20,0x40,0x20,0x1F},
['W']={0x7F,0x20,0x18,0x20,0x7F},
['X']={0x63,0x14,0x08,0x14,0x63},
['Y']={0x03,0x04,0x78,0x04,0x03},
['Z']={0x61,0x51,0x49,0x45,0x43},

['a']={0x20,0x54,0x54,0x54,0x78},
['b']={0x7F,0x48,0x44,0x44,0x38},
['c']={0x38,0x44,0x44,0x44,0x20},
['d']={0x38,0x44,0x44,0x48,0x7F},
['e']={0x38,0x54,0x54,0x54,0x18},
['f']={0x08,0x7E,0x09,0x01,0x02},
['g']={0x0C,0x52,0x52,0x52,0x3E},
['h']={0x7F,0x08,0x04,0x04,0x78},
['i']={0x00,0x44,0x7D,0x40,0x00},
['j']={0x20,0x40,0x44,0x3D,0x00},
['k']={0x7F,0x10,0x28,0x44,0x00},
['l']={0x00,0x41,0x7F,0x40,0x00},
['m']={0x7C,0x04,0x18,0x04,0x78},
['n']={0x7C,0x08,0x04,0x04,0x78},
['o']={0x38,0x44,0x44,0x44,0x38},
['p']={0x7C,0x14,0x14,0x14,0x08},
['q']={0x08,0x14,0x14,0x18,0x7C},
['r']={0x7C,0x08,0x04,0x04,0x08},
['s']={0x48,0x54,0x54,0x54,0x20},
['t']={0x04,0x3F,0x44,0x40,0x20},
['u']={0x3C,0x40,0x40,0x20,0x7C},
['v']={0x1C,0x20,0x40,0x20,0x1C},
['w']={0x3C,0x40,0x30,0x40,0x3C},
['x']={0x44,0x28,0x10,0x28,0x44},
['y']={0x0C,0x50,0x50,0x50,0x3C},
['z']={0x44,0x64,0x54,0x4C,0x44}
};

/* ================= SHIFT ================= */
/* NOTE:
   First bit shifted goes to C84
   So we must output columns in REVERSE order
*/
static void ShiftOutRow(uint8_t *row_data)
{
    for(int col = 0; col < 84; col++)
    {
        int byte = col / 8;
        int bit  = col % 8;

        uint8_t val = (row_data[byte] >> bit) & 1;

        HAL_GPIO_WritePin(GPIOA,
            DATA_Pin,
            val ? GPIO_PIN_RESET : GPIO_PIN_SET);

        HAL_GPIO_WritePin(GPIOA, SRCLK_Pin, GPIO_PIN_SET);
        HAL_GPIO_WritePin(GPIOA, SRCLK_Pin, GPIO_PIN_RESET);
    }

    HAL_GPIO_WritePin(GPIOA, RCLK_Pin, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOA, RCLK_Pin, GPIO_PIN_RESET);
}


/* ================= CORE SCAN ================= */
void Matrix_Task(void)
{
    static uint32_t last_scan = 0;

    /* 1 ms per row */
    if(HAL_GetTick() - last_scan < 1)
        return;

    last_scan = HAL_GetTick();

    /* turn OFF all rows first */
    for(int r = 0; r < NUM_ROWS; r++)
        HAL_GPIO_WritePin(GPIOA, ROW_PINS[r], GPIO_PIN_SET);

    /* shift next row */
    ShiftOutRow(display_buffer[current_row]);

    /* enable active row */
    HAL_GPIO_WritePin(GPIOA,
        ROW_PINS[current_row],
        GPIO_PIN_RESET);

    current_row++;
    if(current_row >= NUM_ROWS)
        current_row = 0;
}


/* ================= DRAW ================= */
void Matrix_Init(void)
{
    Matrix_Clear();
}

void Matrix_Clear(void)
{
    memset(display_buffer,0,sizeof(display_buffer));
}

void Matrix_SetPixel(int r,int c,uint8_t state)
{
    if(r<0||r>=NUM_ROWS||c<0||c>=NUM_COLS) return;

    int byte=c/8;
    int bit=c%8;

    if(state)
        display_buffer[r][byte]|=(1<<bit);
    else
        display_buffer[r][byte]&=~(1<<bit);
}

void Matrix_DrawChar(int row,int col,char c)
{
    for(int x=0;x<5;x++)
    {
        uint8_t column=font5x7[(int)c][x];

        for(int y=0;y<7;y++)
        {
            Matrix_SetPixel(row+y,col+x,
                (column>>y)&1);
        }
    }
}

void Matrix_DrawText(int row,int col,const char *text)
{
    while(*text)
    {
        Matrix_DrawChar(row,col,*text);
        col+=6;
        text++;
    }
}

void Matrix_ScrollText(const char *text,int offset)
{
    int x=-offset;

    while(*text)
    {
        Matrix_DrawChar(0,x,*text);
        x+=6;
        text++;
    }
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == TIM3)
    {
        // Turn OFF all rows
        for (int r = 0; r < NUM_ROWS; r++)
        {
            HAL_GPIO_WritePin(GPIOA, ROW_PINS[r], GPIO_PIN_SET);
        }

        // Short dead time (prevents ghosting)
        for (volatile int i = 0; i < 20; i++) { __NOP(); }   // ~1–2 µs depending on clock

        // Shift out next row data
        ShiftOutRow(display_buffer[current_row]);

        // Another tiny delay after shift (stabilize latches)
        for (volatile int i = 0; i < 10; i++) { __NOP(); }

        // Turn ON current row
        HAL_GPIO_WritePin(GPIOA, ROW_PINS[current_row], GPIO_PIN_RESET);

        current_row = (current_row + 1) % NUM_ROWS;
    }
}
